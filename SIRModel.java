import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;



/**
 * SIR model.
 *
 * @author Jeffrey Chan, 2021.
 */
public class SIRModel
{

    /**
     * Default constructor, modify as needed.
     */
    public SIRModel() {

    } // end of SIRModel()


    /**
     * Run the SIR epidemic model to completion, i.e., until no more changes to the states of the vertices for a whole iteration.
     *
     * @param graph Input contracts graph.
     * @param seedVertices Set of seed, infected vertices.
     * @param infectionProb Probability of infection.
     * @param recoverProb Probability that a vertex can become recovered.
     * @param sirModelOutWriter PrintWriter to output the necessary information per iteration (see specs for details).
     */
    public void runSimulation(ContactsGraph graph, String[] seedVertices,
        float infectionProb, float recoverProb, PrintWriter sirModelOutWriter)
    {
        // IMPLEMENT ME!
    	//1.Determine initial infected vertices
    	sirModelOutWriter.println("InitialState");
    	DynamicArrayMinimal infectedList = new DynamicArrayMinimal();
    	DynamicArrayMinimal recoveredList = new DynamicArrayMinimal();
    	DynamicArrayMinimal currentInfectedList = new DynamicArrayMinimal();
		DynamicArrayMinimal currentRecoveredList = new DynamicArrayMinimal();
    	
    	
    	// - Determine the initialState
    	Map< String, SIRState> initialState = new HashMap<String, SIRState>();
    	
    	//deep copies the state
    	for(String key : graph.getState().keySet()) {
    		initialState.put(key, graph.getState().get(key));
    	}
    	//find out the infected case which are not in the seed vertices
    	for(String key : initialState.keySet()) {
    		if(initialState.get(key) == SIRState.I) {
    			infectedList.add(key);
    		}
    	}
    	//add the vertex in seedVertices to the infectedList
    	for(String vertex : seedVertices) {
    		if(initialState.get(vertex) == SIRState.S) {
    			graph.toggleVertexState(vertex);
    			if(infectedList.search(vertex) < 0) {
    				infectedList.add(vertex);
    			}
        		
    		}
    		
    	}
    	currentInfectedList = infectedList;
    	currentRecoveredList = recoveredList;
    	initialState.clear();
    	
    	for(String key : graph.getState().keySet()) {
    		initialState.put(key, graph.getState().get(key));
    		
    	}
    	
    
    	// - Get all the vertex in the graph
    	DynamicArrayMinimal vertexList = new DynamicArrayMinimal();	
    	
    	for(String key : initialState.keySet()) {
    		vertexList.add(key);
    	}
    	int unChange = 0;
    	
    	sirModelOutWriter.println(currentInfectedList.toString() + " : " + currentRecoveredList.toString());
    	
    	for (String vertex: seedVertices) {
    		infectedList.add(vertex);
    	}
    	
    	int infectionSteps = 0;
    	while(!(infectedList.size() == 0 || unChange == 10)) {
    		//create prevState to keep track the previous state, in case the state change
    		//Reset the currentList in every iteration
    		
    		currentInfectedList = new DynamicArrayMinimal();
    		currentRecoveredList = new DynamicArrayMinimal();
    		Map< String, SIRState> prevState = new HashMap<String, SIRState>();
    		for(String key : initialState.keySet()) {
        		prevState.put(key, initialState.get(key));
        		
        	}
    		
        	for(int i = 0; i < infectedList.size(); i++) {
        		infectionSteps++;
        		String vertex = infectedList.get(i);
        		infectionState(vertex, graph, initialState,infectedList, infectionProb, recoveredList, recoverProb, infectionSteps);   
        		//recoverState(graph, initialState,infectedList, recoveredList, recoverProb);
        	}
        	
        	
        	//deep copies the state
        	initialState.clear();
        	
        	for(String key : graph.getState().keySet()) {
        		initialState.put(key, graph.getState().get(key));
        		
        	}
        	
        	//compare with previous state
    		if(prevState.equals(initialState)) {
    			unChange++;
    			
    		} else {
    			unChange = 0;
    		}
    		
    		
    	}
    	
    	
    	//While loop condition: all seed are recoverd or the state hasnt change after 10 iterations    	
    	//Check the state, calculate the probability which a vertex can change its state
    	//Save the state
    	//Store the infected vertex in an array, another for recovery vertex
    	
    } // end of runSimulation()
    
    private void infectionState(String vertLabel, ContactsGraph graph, Map<String,SIRState>state, DynamicArrayMinimal infectedList,float infectionProb, DynamicArrayMinimal recoveredList, float recoverProb, int infectionSteps) {
    	//2.Find the neighbors of infected seeds by using k-hop neighbor with k = max number of Edge can generated by the current number of vertices
    	DynamicArrayMinimal currentInfectinList = new DynamicArrayMinimal();
    	PrintWriter os = new PrintWriter(System.out, true);
    	int vertexNum = state.size();
    	int maxEdge = (vertexNum*(vertexNum - 1)) / 2;

    	String neighbor[] = graph.kHopNeighbours(1, vertLabel);
    	for(int i = 0; i < neighbor.length; i++) {
    		if(isInfected(infectionProb)) {
    			if(state.get(neighbor[i]) == SIRState.S) {
    				graph.toggleVertexState(neighbor[i]); //Only change the state which is "S"
            		infectedList.add(neighbor[i]);
            		currentInfectinList.add(neighbor[i]);
            	
    			}
        		
    		}
			
    	}
    	
    	os.println(infectionSteps + ": " + currentInfectinList.toString() + " : " + recoverState(graph, state, infectedList, recoveredList, recoverProb));
    	
    }
    
    private String recoverState(ContactsGraph graph, Map<String,SIRState>state,DynamicArrayMinimal infectedList, DynamicArrayMinimal recoveredList, float recoverProb) {
    	PrintWriter os = new PrintWriter(System.out,true);
    	DynamicArrayMinimal currentRecoveredList = new DynamicArrayMinimal();
    	
    	//Simulate the recoverState of vertices in infectedList
    	for(int i = 0; i < infectedList.size(); i++) {
    		if(isRecovered(recoverProb)) {
    			graph.toggleVertexState(infectedList.get(i));
				recoveredList.add(infectedList.get(i));
				currentRecoveredList.add(infectedList.get(i));
    			infectedList.delete(i);   			
    		}    		
    	}	
    	return currentRecoveredList.toString();
    	
    }
    
    private boolean isInfected(float infectionProb) {
    	Random random = new Random();
    	
		
    	float result = 0.1f + random.nextFloat() * (1f - 0.1f);
    	
    	if (result <= infectionProb) {
    		return true; 
    	}
    	return false;
    }
    
    private boolean isRecovered(float recoverProb) {
    	Random random = new Random();
    	float result = 0.1f + random.nextFloat() * (1f - 0.1f);
		
    	if (result <= recoverProb) {
    		
    		return true; 
    	}
    	return false;
    }
} // end of class SIRModel
